
<!doctype html>

<html>
<head>
  <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">
  <meta name="theme-color" content="#4F7DC9">
  <meta charset="UTF-8">
  <title>Amazon Personalize POC in a box</title>
  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Source+Code+Pro:400|Roboto:400,300,400italic,500,700|Roboto+Mono">
  <link rel="stylesheet" href="//fonts.googleapis.com/icon?family=Material+Icons">
  <link rel="stylesheet" href="https://storage.googleapis.com/codelab-elements/codelab-elements.css">
  <style>
    .success {
      color: #1e8e3e;
    }
    .error {
      color: red;
    }
  </style>
</head>
<body>
  <google-codelab-analytics gaid="UA-49880327-14"></google-codelab-analytics>
  <google-codelab codelab-gaid=""
                  id="amazon-personalize-poc-in-a-box"
                  title="Amazon Personalize POC in a box"
                  environment="web"
                  feedback-link="https://github.com/recohut/reco-step/issues">
    
      <google-codelab-step label="Introduction" duration="5">
        <h2 is-upgraded>What you&#39;ll learn?</h2>
<p>In this workshop you will build your very own recommendation model that will recommend movies to users based on their past preferences. You will further improve the recommendation model to take into account a user&#39;s interactions with movie items to provide accurate recommendations. This workshop will use the publicly available movie lens dataset.</p>
<h2 is-upgraded>Why is this important?</h2>
<p>Amazon Personalize is an advanced tool for building recommender systems, that supports AutoML and Real-time.</p>
<h2 is-upgraded>How it will work?</h2>
<ol type="1">
<li>Setup the environment using CloudFormation template</li>
<li>Open the SageMaker Jupyter Lab instance</li>
<li>Extract, Transform &amp; Load</li>
<li>Train the recommender model and build the campaign</li>
<li>Evaluate solution versions</li>
<li>Deploy campaigns</li>
<li>Create filters</li>
<li>Interact with the campaigns</li>
<li>Clean the environment by deleting all the resources</li>
</ol>
<h2 is-upgraded>Who is this for?</h2>
<ul>
<li>People who are new in deep learning</li>
<li>People looking to use tensorflow keras to build deep recommender models</li>
</ul>
<h2 is-upgraded>Important resources</h2>
<ul>
<li><a href="https://nbviewer.jupyter.org/github/recohut-admin/reco-amazon-personalize/tree/master/next_steps/workshops/POC_in_a_box/completed/" target="_blank">Notebooks</a></li>
</ul>


      </google-codelab-step>
    
      <google-codelab-step label="Setup the environment with CloudFormation" duration="5">
        <p>The first step is to deploy a CloudFormation template that will perform much of the initial setup work for you. In another browser window or tab, log in to your AWS account. Once you have done that, open <a href="https://console.aws.amazon.com/cloudformation/home?region=us-east-1#/stacks/create/template?stackName=PersonalizePOC&templateURL=https://chriskingpartnershare.s3.amazonaws.com/PersonalizePOC.yaml" target="_blank">this</a> link in a new tab to start the process of deploying the items you need via CloudFormation.</p>


      </google-codelab-step>
    
      <google-codelab-step label="ETL for Interaction data" duration="10">
        <h2 is-upgraded>Extract</h2>
<p>Download from official MovieLens source. The head will look like this:</p>
<p class="image-container"><img alt="img/_markdowns-raw-recostep-stage-amazon-personalize-poc-in-a-box-untitled.png" src="img/159bd7ea801ed1b8.png"></p>
<h2 is-upgraded>Transform</h2>
<p><strong>Convert the datetime format</strong></p>
<p>The int64 format is clearly suitable for userId and movieId. However, we need to dive deeper to understand the timestamps in the data. To use Amazon Personalize, you need to save timestamps in Unix Epoch format. We will use the below python code to transform:</p>
<pre><code language="language-python" class="language-python">print(arb_time_stamp)
print(datetime.utcfromtimestamp(arb_time_stamp).strftime(&#39;%Y-%m-%d %H:%M:%S&#39;))

Output::
964982681.0
2000-07-30 18:44:41
</code></pre>
<p><strong>Convert explicit to implicit</strong></p>
<p>Our dataset has an additional column, rating, which can be dropped from the dataset after we have leveraged it to focus on positive interactions. Since this is an explicit feedback movie rating dataset, it includes movies rated from 1 to 5, we want to include only moves that weree &#34;liked&#34; by the users, and simulate a implicit dataset that is more like what data would be gathered by a VOD platform. For that so we will filter out all interactions under 2 out of 5, and create an EVENT_Type of &#34;click&#34; and an EVENT_Type of &#34;watch&#34;. We will then assign all movies rated 2 and above as &#34;click&#34; and movies above 4 and above as &#34;click&#34; and &#34;watch&#34;.</p>
<pre><code language="language-python" class="language-python">watched_df = original_data.copy()
watched_df = watched_df[watched_df[&#39;rating&#39;] &gt; 3]
watched_df = watched_df[[&#39;userId&#39;, &#39;movieId&#39;, &#39;timestamp&#39;]]
watched_df[&#39;EVENT_TYPE&#39;]=&#39;watch&#39;

clicked_df = original_data.copy()
clicked_df = clicked_df[clicked_df[&#39;rating&#39;] &gt; 1]
clicked_df = clicked_df[[&#39;userId&#39;, &#39;movieId&#39;, &#39;timestamp&#39;]]
clicked_df[&#39;EVENT_TYPE&#39;]=&#39;click&#39;
</code></pre>
<p><strong>Change column names</strong></p>
<p>Amazon Personalize has default column names for users, items, and timestamp. These default column names are USER_ID, ITEM_ID, AND TIMESTAMP.</p>
<pre><code language="language-python" class="language-python">interactions_df.rename(columns = {&#39;userId&#39;:&#39;USER_ID&#39;, &#39;movieId&#39;:&#39;ITEM_ID&#39;, 
                              &#39;timestamp&#39;:&#39;TIMESTAMP&#39;}, inplace = True)
</code></pre>
<p><strong>Create the dataset group</strong></p>
<p>The highest level of isolation and abstraction with Amazon Personalize is a dataset group. Information stored within one of these dataset groups has no impact on any other dataset group or models created from one - they are completely isolated. The following cell will create a new dataset group with the name <code>personalize-poc-movielens</code>.</p>
<pre><code language="language-python" class="language-python">create_dataset_group_response = personalize.create_dataset_group(name=&#34;personalize-poc-movielens&#34;)
</code></pre>
<p><strong>Create the dataset</strong></p>
<p>First, define a schema to tell Amazon Personalize what type of dataset you are uploading. There are several reserved and mandatory keywords required in the schema, based on the type of dataset.</p>
<pre><code language="language-python" class="language-python">interactions_schema = schema = {
    &#34;type&#34;: &#34;record&#34;,
    &#34;name&#34;: &#34;Interactions&#34;,
    &#34;namespace&#34;: &#34;com.amazonaws.personalize.schema&#34;,
    &#34;fields&#34;: [
        {
            &#34;name&#34;: &#34;USER_ID&#34;,
            &#34;type&#34;: &#34;string&#34;
        },
        {
            &#34;name&#34;: &#34;ITEM_ID&#34;,
            &#34;type&#34;: &#34;string&#34;
        },
        {
            &#34;name&#34;: &#34;EVENT_TYPE&#34;,
            &#34;type&#34;: &#34;string&#34;
        },
        {
            &#34;name&#34;: &#34;TIMESTAMP&#34;,
            &#34;type&#34;: &#34;long&#34;
        }
    ],
    &#34;version&#34;: &#34;1.0&#34;
}

create_schema_response = personalize.create_schema(
    name = &#34;personalize-poc-movielens-interactions&#34;,
    schema = json.dumps(interactions_schema)
)
</code></pre>
<p>With a schema created, you can create a dataset within the dataset group.</p>
<pre><code language="language-python" class="language-python">dataset_type = &#34;INTERACTIONS&#34;
create_dataset_response = personalize.create_dataset(
    name = &#34;personalize-poc-movielens-ints&#34;,
    datasetType = dataset_type,
    datasetGroupArn = dataset_group_arn,
    schemaArn = interaction_schema_arn
)
</code></pre>
<h2 is-upgraded>Load</h2>
<p>So far, we have downloaded, manipulated, and saved the data onto the Amazon EBS instance attached to the instance running this Jupyter notebook. However, Amazon Personalize will need an S3 bucket to act as the source of your data, as well as IAM roles for accessing that bucket.</p>
<pre><code language="language-python" class="language-python">s3 = boto3.client(&#39;s3&#39;)
account_id = boto3.client(&#39;sts&#39;).get_caller_identity().get(&#39;Account&#39;)
bucket_name = account_id + &#34;-&#34; + region + &#34;-&#34; + &#34;personalizepocvod&#34;
print(bucket_name)
if region == &#34;us-east-1&#34;:
    s3.create_bucket(Bucket=bucket_name)
else:
    s3.create_bucket(
        Bucket=bucket_name,
        CreateBucketConfiguration={&#39;LocationConstraint&#39;: region}
        )
</code></pre>
<p>Now that your Amazon S3 bucket has been created, upload the CSV file of our user-item-interaction data.</p>
<pre><code language="language-python" class="language-python">interactions_file_path = data_dir + &#34;/&#34; + interactions_filename
boto3.Session().resource(&#39;s3&#39;).Bucket(bucket_name).Object(interactions_filename).upload_file(interactions_file_path)
interactions_s3DataPath = &#34;s3://&#34;+bucket_name+&#34;/&#34;+interactions_filename
</code></pre>


      </google-codelab-step>
    
      <google-codelab-step label="ETL for Item metadata" duration="10">
        <h2 is-upgraded>Extract</h2>
<p>Download from official MovieLens source. The head will look like this:</p>
<p class="image-container"><img alt="img/_markdowns-raw-recostep-stage-amazon-personalize-poc-in-a-box-untitled-1.png" src="img/53a6b60999e51c38.png"></p>
<h2 is-upgraded>Transform</h2>
<p><strong>Create the movie release year column</strong></p>
<p>The title includes the year of the movies release. Let&#39;s make that another column of metadata:</p>
<pre><code language="language-python" class="language-python">original_data[&#39;year&#39;] =original_data[&#39;title&#39;].str.extract(&#39;.*\((.*)\).*&#39;,expand = False)
</code></pre>
<p><strong>Remove the title column</strong></p>
<p>From an item metadata perspective, we only want to include information that is relevant to training a model and/or filtering resulte, so we will drop the title, retaining the genre information.</p>
<p><strong>Changing column names</strong></p>
<p>Amazon Personalize has a default column for ITEM_ID that will map to our movieId, and now we can flesh out more information by specifying GENRE as well.</p>
<pre><code language="language-python" class="language-python">itemmetadata_df.rename(columns = {&#39;genres&#39;:&#39;GENRE&#39;, &#39;movieId&#39;:&#39;ITEM_ID&#39;, &#39;year&#39;:&#39;YEAR&#39;}, inplace = True)
</code></pre>
<p><strong>Creating the dataset and loading to S3</strong></p>
<pre><code language="language-python" class="language-python">itemmetadata_schema = {
    &#34;type&#34;: &#34;record&#34;,
    &#34;name&#34;: &#34;Items&#34;,
    &#34;namespace&#34;: &#34;com.amazonaws.personalize.schema&#34;,
    &#34;fields&#34;: [
        {
            &#34;name&#34;: &#34;ITEM_ID&#34;,
            &#34;type&#34;: &#34;string&#34;
        },
        {
            &#34;name&#34;: &#34;GENRE&#34;,
            &#34;type&#34;: &#34;string&#34;,
            &#34;categorical&#34;: True
        },{
            &#34;name&#34;: &#34;YEAR&#34;,
            &#34;type&#34;: &#34;int&#34;,
        },
        
    ],
    &#34;version&#34;: &#34;1.0&#34;
}

create_schema_response = personalize.create_schema(
    name = &#34;personalize-poc-movielens-item&#34;,
    schema = json.dumps(itemmetadata_schema)
)
</code></pre>
<pre><code language="language-python" class="language-python">dataset_type = &#34;ITEMS&#34;
create_dataset_response = personalize.create_dataset(
    name = &#34;personalize-poc-movielens-items&#34;,
    datasetType = dataset_type,
    datasetGroupArn = dataset_group_arn,
    schemaArn = itemmetadataschema_arn
)
</code></pre>
<pre><code language="language-python" class="language-python">itemmetadata_file_path = data_dir + &#34;/&#34; + itemmetadata_filename
boto3.Session().resource(&#39;s3&#39;).Bucket(bucket_name).Object(itemmetadata_filename).upload_file(itemmetadata_file_path)
interactions_s3DataPath = &#34;s3://&#34;+bucket_name+&#34;/&#34;+itemmetadata_filename
</code></pre>


      </google-codelab-step>
    
      <google-codelab-step label="Import the dataset" duration="5">
        <p>Earlier you created the dataset group and dataset to house your information, so now you will execute an import job that will load the data from the S3 bucket into the Amazon Personalize dataset.</p>
<h2 is-upgraded>Import interaction dataset</h2>
<pre><code language="language-python" class="language-python">create_dataset_import_job_response = personalize.create_dataset_import_job(
    jobName = &#34;personalize-poc-import1&#34;,
    datasetArn = interactions_dataset_arn,
    dataSource = {
        &#34;dataLocation&#34;: &#34;s3://{}/{}&#34;.format(bucket_name, interactions_filename)
    },
    roleArn = role_arn
)
</code></pre>
<h2 is-upgraded>Import item meta dataset</h2>
<pre><code language="language-python" class="language-python">create_dataset_import_job_response = personalize.create_dataset_import_job(
    jobName = &#34;personalize-poc-item-import1&#34;,
    datasetArn = items_dataset_arn,
    dataSource = {
        &#34;dataLocation&#34;: &#34;s3://{}/{}&#34;.format(bucket_name, itemmetadata_filename)
    },
    roleArn = role_arn
)
</code></pre>


      </google-codelab-step>
    
      <google-codelab-step label="Create the solution" duration="10">
        <p>We will build 3 solutons:</p>
<ol type="1">
<li>User Personalization - what items are most relevant to a specific user.</li>
<li>Similar Items - given an item, what items are similar to it.</li>
<li>Personalized Ranking - given a user and a collection of items, in what order are they most releveant.</li>
</ol>
<h2 is-upgraded>User Personalization</h2>
<p>The User-Personalization (aws-user-personalization) recipe is optimized for all USER_PERSONALIZATION recommendation scenarios. When recommending items, it uses automatic item exploration.</p>
<p>With automatic exploration, Amazon Personalize automatically tests different item recommendations, learns from how users interact with these recommended items, and boosts recommendations for items that drive better engagement and conversion. This improves item discovery and engagement when you have a fast-changing catalog, or when new items, such as news articles or promotions, are more relevant to users when fresh.</p>
<p>You can balance how much to explore (where items with less interactions data or relevance are recommended more frequently) against how much to exploit (where recommendations are based on what we know or relevance). Amazon Personalize automatically adjusts future recommendations based on implicit user feedback.</p>
<pre><code language="language-python" class="language-python"># create the solution
user_personalization_create_solution_response = personalize.create_solution(
    name = &#34;personalize-poc-userpersonalization&#34;,
    datasetGroupArn = dataset_group_arn,
    recipeArn = user_personalization_recipe_arn
)
user_personalization_solution_arn = user_personalization_create_solution_response[&#39;solutionArn&#39;]

# create the solution version
userpersonalization_create_solution_version_response = personalize.create_solution_version(
    solutionArn = user_personalization_solution_arn
)
userpersonalization_solution_version_arn = userpersonalization_create_solution_version_response[&#39;solutionVersionArn&#39;]
</code></pre>
<h2 is-upgraded>S<strong>IMS</strong></h2>
<p>SIMS is one of the oldest algorithms used within Amazon for recommendation systems. A core use case for it is when you have one item and you want to recommend items that have been interacted with in similar ways over your entire user base. This means the result is not personalized per user. Sometimes this leads to recommending mostly popular items, so there is a hyperparameter that can be tweaked which will reduce the popular items in your results.</p>
<p>For our use case, using the Movielens data, let&#39;s assume we pick a particular movie. We can then use SIMS to recommend other movies based on the interaction behavior of the entire user base. The results are not personalized per user, but instead, differ depending on the movie we chose as our input.</p>
<pre><code language="language-python" class="language-python"># create the solution
sims_create_solution_response = personalize.create_solution(
    name = &#34;personalize-poc-sims&#34;,
    datasetGroupArn = dataset_group_arn,
    recipeArn = SIMS_recipe_arn
)
sims_solution_arn = sims_create_solution_response[&#39;solutionArn&#39;]

# create the solution version
sims_create_solution_version_response = personalize.create_solution_version(
    solutionArn = sims_solution_arn
)
sims_solution_version_arn = sims_create_solution_version_response[&#39;solutionVersionArn&#39;]
</code></pre>
<h2 is-upgraded>Personalized Ranking</h2>
<p>Personalized Ranking is an interesting application of HRNN. Instead of just recommending what is most probable for the user in question, this algorithm takes in a user and a list of items as well. The items are then rendered back in the order of most probable relevance for the user. The use case here is for filtering on unique categories that you do not have item metadata to create a filter, or when you have a broad collection that you would like better ordered for a particular user.</p>
<p>For our use case, using the MovieLens data, we could imagine that a VOD application may want to create a shelf of comic book movies, or movies by a specific director. We most likely have these lists based title metadata we have. We would use personalized ranking to re-order the list of movies for each user, based on their previous tagging history.</p>
<pre><code language="language-python" class="language-python"># create the solution
rerank_create_solution_response = personalize.create_solution(
    name = &#34;personalize-poc-rerank&#34;,
    datasetGroupArn = dataset_group_arn,
    recipeArn = rerank_recipe_arn
)
rerank_solution_arn = rerank_create_solution_response[&#39;solutionArn&#39;]

# create the solution version
rerank_create_solution_version_response = personalize.create_solution_version(
    solutionArn = rerank_solution_arn
)
rerank_solution_version_arn = rerank_create_solution_version_response[&#39;solutionVersionArn&#39;]
</code></pre>


      </google-codelab-step>
    
      <google-codelab-step label="Hyperparameter tuning" duration="5">
        <p>Personalize offers the option of running hyperparameter tuning when creating a solution. Because of the additional computation required to perform hyperparameter tuning, this feature is turned off by default. Therefore, the solutions we created above, will simply use the default values of the hyperparameters for each recipe. For more information about hyperparameter tuning, see the <a href="https://docs.aws.amazon.com/personalize/latest/dg/customizing-solution-config-hpo.html" target="_blank">documentation</a>.</p>
<p>If you have settled on the correct recipe to use, and are ready to run hyperparameter tuning, the following code shows how you would do so, using SIMS as an example.</p>
<pre><code language="language-python" class="language-python">sims_create_solution_response = personalize.create_solution(
    name = &#34;personalize-poc-sims-hpo&#34;,
    datasetGroupArn = dataset_group_arn,
    recipeArn = SIMS_recipe_arn,
    performHPO=True
)

sims_solution_arn = sims_create_solution_response[&#39;solutionArn&#39;]
print(json.dumps(sims_create_solution_response, indent=2))
</code></pre>
<p>If you already know the values you want to use for a specific hyperparameter, you can also set this value when you create the solution. The code below shows how you could set the value for the <code>popularity_discount_factor</code> for the SIMS recipe.</p>
<pre><code language="language-python" class="language-python">sims_create_solution_response = personalize.create_solution(
    name = &#34;personalize-poc-sims-set-hp&#34;,
    datasetGroupArn = dataset_group_arn,
    recipeArn = SIMS_recipe_arn,
    solutionConfig = {
        &#39;algorithmHyperParameters&#39;: {
            &#39;popularity_discount_factor&#39;: &#39;0.7&#39;
        }
    }
)

sims_solution_arn = sims_create_solution_response[&#39;solutionArn&#39;]
print(json.dumps(sims_create_solution_response, indent=2))
</code></pre>


      </google-codelab-step>
    
      <google-codelab-step label="Evaluating solution versions" duration="10">
        <p>Let&#39;s take a look at the evaluation metrics for each of the solutions produced.</p>
<h2 is-upgraded>Evaluation of User Personalization solution</h2>
<pre><code language="language-python" class="language-python">user_personalization_solution_metrics_response = personalize.get_solution_metrics(
    solutionVersionArn = userpersonalization_solution_version_arn
)

print(json.dumps(user_personalization_solution_metrics_response, indent=2))
</code></pre>
<pre><code language="language-json" class="language-json">{
  &#34;solutionVersionArn&#34;: &#34;arn:aws:personalize:us-east-1:136455442858:solution/personalize-poc-userpersonalization/236f000b&#34;,
  &#34;metrics&#34;: {
    &#34;coverage&#34;: 0.0791,
    &#34;mean_reciprocal_rank_at_25&#34;: 0.269,
    &#34;normalized_discounted_cumulative_gain_at_10&#34;: 0.2687,
    &#34;normalized_discounted_cumulative_gain_at_25&#34;: 0.3321,
    &#34;normalized_discounted_cumulative_gain_at_5&#34;: 0.2279,
    &#34;precision_at_10&#34;: 0.0571,
    &#34;precision_at_25&#34;: 0.0379,
    &#34;precision_at_5&#34;: 0.075
  },
  &#34;ResponseMetadata&#34;: {
    &#34;RequestId&#34;: &#34;fa6f0e49-b87d-48ce-ab27-80e61a1ab395&#34;,
    &#34;HTTPStatusCode&#34;: 200,
    &#34;HTTPHeaders&#34;: {
      &#34;content-type&#34;: &#34;application/x-amz-json-1.1&#34;,
      &#34;date&#34;: &#34;Thu, 17 Sep 2020 00:41:11 GMT&#34;,
      &#34;x-amzn-requestid&#34;: &#34;fa6f0e49-b87d-48ce-ab27-80e61a1ab395&#34;,
      &#34;content-length&#34;: &#34;417&#34;,
      &#34;connection&#34;: &#34;keep-alive&#34;
    },
    &#34;RetryAttempts&#34;: 0
  }
}
</code></pre>
<p>The normalized discounted cumulative gain above tells us that at 5 items, we have less than a (38% for full 22% for small) chance in a recommendation being a part of a user&#39;s interaction history (in the hold out phase from training and validation). Around 13% of the recommended items are unique, and we have a precision of only (14% for full, 7.5% for small) in the top 5 recommended items.</p>
<p>This is clearly not a great model, but keep in mind that we had to use rating data for our interactions because Movielens is an explicit dataset based on ratings. The Timestamps also were from the time that the movie was rated, not watched, so the order is not the same as the order a viewer would watch movies.</p>
<h2 is-upgraded>Evaluation of SIMS solution</h2>
<pre><code language="language-python" class="language-python">sims_solution_metrics_response = personalize.get_solution_metrics(
    solutionVersionArn = sims_solution_version_arn
)

print(json.dumps(sims_solution_metrics_response, indent=2))
</code></pre>
<pre><code language="language-json" class="language-json">{
  &#34;solutionVersionArn&#34;: &#34;arn:aws:personalize:us-east-1:136455442858:solution/personalize-poc-sims/c1a33236&#34;,
  &#34;metrics&#34;: {
    &#34;coverage&#34;: 0.1861,
    &#34;mean_reciprocal_rank_at_25&#34;: 0.1669,
    &#34;normalized_discounted_cumulative_gain_at_10&#34;: 0.2234,
    &#34;normalized_discounted_cumulative_gain_at_25&#34;: 0.2895,
    &#34;normalized_discounted_cumulative_gain_at_5&#34;: 0.1889,
    &#34;precision_at_10&#34;: 0.0588,
    &#34;precision_at_25&#34;: 0.0418,
    &#34;precision_at_5&#34;: 0.0824
  },
  &#34;ResponseMetadata&#34;: {
    &#34;RequestId&#34;: &#34;662598d1-86f0-49a1-98a9-1c3924882f4b&#34;,
    &#34;HTTPStatusCode&#34;: 200,
    &#34;HTTPHeaders&#34;: {
      &#34;content-type&#34;: &#34;application/x-amz-json-1.1&#34;,
      &#34;date&#34;: &#34;Thu, 17 Sep 2020 00:41:11 GMT&#34;,
      &#34;x-amzn-requestid&#34;: &#34;662598d1-86f0-49a1-98a9-1c3924882f4b&#34;,
      &#34;content-length&#34;: &#34;404&#34;,
      &#34;connection&#34;: &#34;keep-alive&#34;
    },
    &#34;RetryAttempts&#34;: 0
  }
}
</code></pre>
<p>In this example we are seeing a slightly elevated precision at 5 items, a little over (4.5% for full, 6.4% for small) this time. Effectively this is probably within the margin of error, but given that no effort was made to mask popularity, it may just be returning super popular results that a large volume of users have interacted with in some way.</p>
<h2 is-upgraded>Evaluation of Personalized Ranking solution</h2>
<pre><code language="language-python" class="language-python">rerank_solution_metrics_response = personalize.get_solution_metrics(
    solutionVersionArn = rerank_solution_version_arn
)

print(json.dumps(rerank_solution_metrics_response, indent=2))
</code></pre>
<pre><code language="language-json" class="language-json">{
  &#34;solutionVersionArn&#34;: &#34;arn:aws:personalize:us-east-1:136455442858:solution/personalize-poc-rerank/eae37049&#34;,
  &#34;metrics&#34;: {
    &#34;coverage&#34;: 0.0038,
    &#34;mean_reciprocal_rank_at_25&#34;: 0.0537,
    &#34;normalized_discounted_cumulative_gain_at_10&#34;: 0.0707,
    &#34;normalized_discounted_cumulative_gain_at_25&#34;: 0.0956,
    &#34;normalized_discounted_cumulative_gain_at_5&#34;: 0.0578,
    &#34;precision_at_10&#34;: 0.0132,
    &#34;precision_at_25&#34;: 0.0113,
    &#34;precision_at_5&#34;: 0.0189
  },
  &#34;ResponseMetadata&#34;: {
    &#34;RequestId&#34;: &#34;01f86e05-9408-4456-97d3-2548d2cc998e&#34;,
    &#34;HTTPStatusCode&#34;: 200,
    &#34;HTTPHeaders&#34;: {
      &#34;content-type&#34;: &#34;application/x-amz-json-1.1&#34;,
      &#34;date&#34;: &#34;Thu, 17 Sep 2020 00:41:11 GMT&#34;,
      &#34;x-amzn-requestid&#34;: &#34;01f86e05-9408-4456-97d3-2548d2cc998e&#34;,
      &#34;content-length&#34;: &#34;406&#34;,
      &#34;connection&#34;: &#34;keep-alive&#34;
    },
    &#34;RetryAttempts&#34;: 0
  }
}
</code></pre>
<p>Just a quick comment on this one, here we see again a precision of near (2.7% for full, 2.2% for small), as this is based on User Personalization, that is to be expected. However the sample items are not the same for validaiton, thus the low scoring.</p>


      </google-codelab-step>
    
      <google-codelab-step label="Deploying campaigns" duration="5">
        <p>At this point, you should have several solutions and at least one solution version for each. Once a solution version is created, it is possible to get recommendations from them, and to get a feel for their overall behavior. We will be deploying each of the solution versions into individual campaigns. Once they are active, there are resources for querying the recommendations, and helper functions to digest the output into something more human-readable.</p>
<h2 is-upgraded>Deploy User Personalization campaign</h2>
<pre><code language="language-python" class="language-python">userpersonalization_create_campaign_response = personalize.create_campaign(
    name = &#34;personalize-poc-userpersonalization&#34;,
    solutionVersionArn = userpersonalization_solution_version_arn,
    minProvisionedTPS = 1
)

userpersonalization_campaign_arn = userpersonalization_create_campaign_response[&#39;campaignArn&#39;]
</code></pre>
<h2 is-upgraded>Deploy SIMS campaign</h2>
<pre><code language="language-python" class="language-python">sims_create_campaign_response = personalize.create_campaign(
    name = &#34;personalize-poc-SIMS&#34;,
    solutionVersionArn = sims_solution_version_arn,
    minProvisionedTPS = 1
)

sims_campaign_arn = sims_create_campaign_response[&#39;campaignArn&#39;]
</code></pre>
<h2 is-upgraded>Deploy Personalized Ranking campaign</h2>
<pre><code language="language-python" class="language-python">rerank_create_campaign_response = personalize.create_campaign(
    name = &#34;personalize-poc-rerank&#34;,
    solutionVersionArn = rerank_solution_version_arn,
    minProvisionedTPS = 1
)

rerank_campaign_arn = rerank_create_campaign_response[&#39;campaignArn&#39;]
</code></pre>


      </google-codelab-step>
    
      <google-codelab-step label="Create filters" duration="5">
        <p>Now that all campaigns are deployed and active, we can create filters. Filters can be created for both Items and Events. A few common use cases for filters in Video On Demand are:</p>
<p>Categorical filters based on Item Metadata - Often your item metadata will have information about thee title such as Genre, Keyword, Year, Decade etc. Filtering on these can provide recommendations within that data, such as action movies.</p>
<p>Events - you may want to filter out certain events and provide results based on those events, such as moving a title from a &#34;suggestions to watch&#34; recommendation to a &#34;watch again&#34; recommendations.</p>
<pre><code language="language-python" class="language-python"># Create a list for the filters:
meta_filter_arns = []

# Iterate through Genres
for genre in genres_to_filter:
    # Start by creating a filter
    try:
        createfilter_response = personalize.create_filter(
            name=genre,
            datasetGroupArn=dataset_group_arn,
            filterExpression=&#39;INCLUDE ItemID WHERE Items.GENRE IN (&#34;&#39;+ genre +&#39;&#34;)&#39;
        )
        # Add the ARN to the list
        meta_filter_arns.append(createfilter_response[&#39;filterArn&#39;])
        print(&#34;Creating: &#34; + createfilter_response[&#39;filterArn&#39;])
    
    # If this fails, wait a bit
    except ClientError as error:
        # Here we only care about raising if it isnt the throttling issue
        if error.response[&#39;Error&#39;][&#39;Code&#39;] != &#39;LimitExceededException&#39;:
            print(error)
        else:    
            time.sleep(120)
            createfilter_response = personalize.create_filter(
                name=genre,
                datasetGroupArn=dataset_group_arn,
                filterExpression=&#39;INCLUDE ItemID WHERE Items.GENRE IN (&#34;&#39;+ genre +&#39;&#34;)&#39;
            )
            # Add the ARN to the list
            meta_filter_arns.append(createfilter_response[&#39;filterArn&#39;])
            print(&#34;Creating: &#34; + createfilter_response[&#39;filterArn&#39;])
</code></pre>
<p>Lets also create 2 event filters for watched and unwatched content</p>
<pre><code language="language-python" class="language-python">createwatchedfilter_response = personalize.create_filter(name=&#39;watched&#39;,
    datasetGroupArn=dataset_group_arn,
    filterExpression=&#39;INCLUDE ItemID WHERE Interactions.event_type IN (&#34;watch&#34;)&#39;
    )

createunwatchedfilter_response = personalize.create_filter(name=&#39;unwatched&#39;,
    datasetGroupArn=dataset_group_arn,
    filterExpression=&#39;EXCLUDE ItemID WHERE Interactions.event_type IN (&#34;watch&#34;)&#39;
    )

interaction_filter_arns = [createwatchedfilter_response[&#39;filterArn&#39;], createunwatchedfilter_response[&#39;filterArn&#39;]]
</code></pre>
<p>Finally since we now have the year available in our item metadata, lets create a decade filter to recommend only moviees releaseed in a given decade, for this workshop we will choosee 1970s cinema.</p>
<pre><code language="language-python" class="language-python">createdecadefilter_response = personalize.create_filter(name=&#39;1970s&#39;,
    datasetGroupArn=dataset_group_arn,
    filterExpression=&#39;INCLUDE ItemID WHERE Items.YEAR &gt;= 1970 AND Items.YEAR &lt; 1980&#39;
    )

decade_filter_arns = [createdecadefilter_response[&#39;filterArn&#39;]]
</code></pre>


      </google-codelab-step>
    
      <google-codelab-step label="Interacting with the campaigns" duration="5">
        <p>SIMS requires just an item as input, and it will return items which users interact with in similar ways to their interaction with the input item. In this particular case the item is a movie.</p>
<p>The cells below will handle getting recommendations from SIMS and rendering the results. Let&#39;s see what the recommendations are for the first item we looked at earlier in this notebook (Terminator 2: Judgment Day).</p>
<pre><code language="language-python" class="language-python">get_recommendations_response = personalize_runtime.get_recommendations(
    campaignArn = sims_campaign_arn,
    itemId = str(589),
)

item_list = get_recommendations_response[&#39;itemList&#39;]
for item in item_list:
    print(get_movie_by_id(movie_id=item[&#39;itemId&#39;]))
</code></pre>
<p>HRNN is one of the more advanced algorithms provided by Amazon Personalize. It supports the personalization of the items for a specific user based on their past behavior and can intake real-time events in order to alter recommendations for a user without retraining.</p>
<p>You can see the recommendations for movies within a given genre. Within a VOD application you could create Shelves (also known as rails or carosels) easily by using these filters. Depending on the information you have about your items, You could also filter on additional information such as keyword, year/decade etc.</p>
<pre><code language="language-python" class="language-python">recommendations_df_shelves = pd.DataFrame()
for filter_arn in meta_filter_arns:
    recommendations_df_shelves = get_new_recommendations_df_by_filter(recommendations_df_shelves, user, filter_arn)
for filter_arn in decade_filter_arns:
    recommendations_df_shelves = get_new_recommendations_df_by_filter(recommendations_df_shelves, user, filter_arn)

recommendations_df_shelves
</code></pre>
<p class="image-container"><img alt="img/_markdowns-raw-recostep-stage-amazon-personalize-poc-in-a-box-untitled-2.png" src="img/198bbe59a24d82d0.png"></p>


      </google-codelab-step>
    
      <google-codelab-step label="Cleaning up" duration="5">
        <h2 is-upgraded>Clean up campiagns</h2>
<p>Start by cleaning up the campaigns. You need to delete campaigns before you can delete the solution versions upon which they are based.</p>
<p>The code below will delete the Campaigns you created.</p>
<pre><code language="language-python" class="language-python">personalize.delete_campaign(
    campaignArn = userpersonalization_campaign_arn
)
personalize.delete_campaign(
    campaignArn = sims_campaign_arn
)
personalize.delete_campaign(
    campaignArn = rerank_campaign_arn
)
</code></pre>
<h2 is-upgraded><strong>Clean up event trackers</strong></h2>
<p>Next, clean up any event trackers. The code below will delete your event tracker.</p>
<pre><code language="language-python" class="language-python">personalize.delete_event_tracker(
    eventTrackerArn = event_tracker_arn
)
</code></pre>
<h2 is-upgraded><strong>Clean up Filters</strong></h2>
<p>Next, clean up any filters. The code below iterate over all filters you created and delete them. Note, if you get an error about a campaign, that is fine, wait for 2 minutes then try the cell below again.</p>
<p>Note: You will not be able to delete the filters until the campaign deletion completes, which may take a few minutes</p>
<pre><code language="language-python" class="language-python">**for** filter_arn **in** meta_filter_arns:
    personalize.delete_filter(
        filterArn = filter_arn
    )
**for** filter_arn **in** interaction_filter_arns:
    personalize.delete_filter(
        filterArn = filter_arn
    )
**for** filter_arn **in** decade_filter_arns:
    personalize.delete_filter(
        filterArn = filter_arn
    )
</code></pre>
<h2 is-upgraded><strong>Clean up solutions</strong></h2>
<p>Next, clean up the solutions. The code below will delete the solutions that were created.</p>
<pre><code language="language-python" class="language-python">personalize.delete_solution(
    solutionArn = user_personalization_solution_arn
)
personalize.delete_solution(
    solutionArn = sims_solution_arn
)
personalize.delete_solution(
    solutionArn = rerank_solution_arn
)
</code></pre>
<h2 is-upgraded><strong>Clean up datasets</strong></h2>
<p>Next, clean up the datasets. The code below will delete the item and interactions datasets.</p>
<pre><code language="language-python" class="language-python">personalize.delete_dataset(
    datasetArn = items_dataset_arn
)
personalize.delete_dataset(
    datasetArn = interactions_dataset_arn
)
</code></pre>
<h2 is-upgraded><strong>Clean up the schemas</strong></h2>
<p>Next, clean up the schemas. You create an interaction and item schema, delete them.</p>
<pre><code language="language-python" class="language-python">personalize.delete_schema(
    schemaArn = interaction_schema_arn
)
personalize.delete_schema(
    schemaArn = itemmetadataschema_arn
)
</code></pre>
<h2 is-upgraded><strong>Clean up the dataset groups</strong></h2>
<p>Finally, clean up the dataset group:</p>
<pre><code language="language-python" class="language-python">personalize.delete_dataset_group(
    datasetGroupArn = dataset_group_arn
)
</code></pre>
<h2 is-upgraded><strong>Clean up the S3 bucket and IAM role</strong></h2>
<p>Start by deleting the role, then empty the bucket, then delete the bucket.</p>
<pre><code language="language-python" class="language-python">iam = boto3.client(&#39;iam&#39;)
</code></pre>
<p>Identify the name of the role you want to delete.</p>
<p>You cannot delete an IAM role which still has policies attached to it. So after you have identified the relevant role, let&#39;s list the attached policies of that role.</p>
<pre><code language="language-python" class="language-python">iam.list_attached_role_policies(
    RoleName = role_name
)
</code></pre>
<p>You need to detach the policies in the result above using the code below. Repeat for each attached policy.</p>
<pre><code language="language-python" class="language-python">iam.detach_role_policy(
    RoleName = role_name,
    PolicyArn = &#34;arn:aws:iam::aws:policy/service-role/AmazonPersonalizeFullAccess&#34;
)
</code></pre>
<pre><code language="language-python" class="language-python">iam.detach_role_policy(
    RoleName = role_name,
    PolicyArn = &#39;arn:aws:iam::aws:policy/AmazonS3FullAccess&#39;
)
</code></pre>
<p>Finally, you should be able to delete the IAM role.</p>
<pre><code language="language-python" class="language-python">iam.delete_role(
    RoleName = role_name
)
</code></pre>
<p>To delete an S3 bucket, it first needs to be empty. The easiest way to delete an S3 bucket, is just to navigate to S3 in the AWS console, delete the objects in the bucket, and then delete the S3 bucket itself.</p>


      </google-codelab-step>
    
      <google-codelab-step label="Conclusion" duration="2">
        <p>Congratulations!</p>
<h2 class="checklist" is-upgraded>What we&#39;ve covered</h2>
<ol type="1">
<li>Setup the environment using CloudFormation template</li>
<li>Open the SageMaker Jupyter Lab instance</li>
<li>Extract, Transform &amp; Load</li>
<li>Train the recommender model and build the campaign</li>
<li>Evaluate solution versions</li>
<li>Deploy campaigns</li>
<li>Create filters</li>
<li>Interact with the campaigns</li>
<li>Clean the environment by deleting all the resources</li>
</ol>
<h2 is-upgraded>Links and References</h2>
<ol type="1">
<li><a href="https://github.com/aws-samples/amazon-personalize-samples/tree/master/next_steps/workshops/POC_in_a_box" target="_blank">https://github.com/aws-samples/amazon-personalize-samples/tree/master/next_steps/workshops/POC_in_a_box</a></li>
<li><a href="https://github.com/apac-ml-tfc/personalize-poc" target="_blank">https://github.com/apac-ml-tfc/personalize-poc</a></li>
<li><a href="https://github.com/lmorri/vodpocinabox" target="_blank">https://github.com/lmorri/vodpocinabox</a></li>
</ol>
<h2 is-upgraded>Have a Question?</h2>
<ul>
<li><a href="https://form.jotform.com/211377288388469" target="_blank">Fill out this form</a></li>
<li><a href="https://github.com/recohut/reco-step/issues" target="_blank">Raise issue on Github</a></li>
</ul>


      </google-codelab-step>
    
  </google-codelab>

  <script src="https://storage.googleapis.com/codelab-elements/native-shim.js"></script>
  <script src="https://storage.googleapis.com/codelab-elements/custom-elements.min.js"></script>
  <script src="https://storage.googleapis.com/codelab-elements/prettify.js"></script>
  <script src="https://storage.googleapis.com/codelab-elements/codelab-elements.js"></script>
  <script src="//support.google.com/inapp/api.js"></script>

</body>
</html>
